<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue 基础 | U世界的V梦想</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="一切皆有可能!">
    
    <link rel="preload" href="/blog-vuepress/assets/css/0.styles.63182871.css" as="style"><link rel="preload" href="/blog-vuepress/assets/js/app.4535e051.js" as="script"><link rel="preload" href="/blog-vuepress/assets/js/2.778d2fa8.js" as="script"><link rel="preload" href="/blog-vuepress/assets/js/42.4608b0fe.js" as="script"><link rel="prefetch" href="/blog-vuepress/assets/js/10.d2b18a5d.js"><link rel="prefetch" href="/blog-vuepress/assets/js/11.c2d489b2.js"><link rel="prefetch" href="/blog-vuepress/assets/js/12.4405f014.js"><link rel="prefetch" href="/blog-vuepress/assets/js/13.9897f59c.js"><link rel="prefetch" href="/blog-vuepress/assets/js/14.bd933c2d.js"><link rel="prefetch" href="/blog-vuepress/assets/js/15.b0808ff0.js"><link rel="prefetch" href="/blog-vuepress/assets/js/16.d977dc29.js"><link rel="prefetch" href="/blog-vuepress/assets/js/17.0e4d2fe0.js"><link rel="prefetch" href="/blog-vuepress/assets/js/18.fbba2dc7.js"><link rel="prefetch" href="/blog-vuepress/assets/js/19.6cd03d48.js"><link rel="prefetch" href="/blog-vuepress/assets/js/20.5898904d.js"><link rel="prefetch" href="/blog-vuepress/assets/js/21.79a4fd7b.js"><link rel="prefetch" href="/blog-vuepress/assets/js/22.6270f2a9.js"><link rel="prefetch" href="/blog-vuepress/assets/js/23.2b3b355d.js"><link rel="prefetch" href="/blog-vuepress/assets/js/24.42539ec5.js"><link rel="prefetch" href="/blog-vuepress/assets/js/25.77342626.js"><link rel="prefetch" href="/blog-vuepress/assets/js/26.266c57d2.js"><link rel="prefetch" href="/blog-vuepress/assets/js/27.25e504ac.js"><link rel="prefetch" href="/blog-vuepress/assets/js/28.aa83c90e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/29.26de06d7.js"><link rel="prefetch" href="/blog-vuepress/assets/js/3.edfa3065.js"><link rel="prefetch" href="/blog-vuepress/assets/js/30.3f3a8c9b.js"><link rel="prefetch" href="/blog-vuepress/assets/js/31.6438b674.js"><link rel="prefetch" href="/blog-vuepress/assets/js/32.6e8407a9.js"><link rel="prefetch" href="/blog-vuepress/assets/js/33.2c741ffe.js"><link rel="prefetch" href="/blog-vuepress/assets/js/34.15377d40.js"><link rel="prefetch" href="/blog-vuepress/assets/js/35.6729fb04.js"><link rel="prefetch" href="/blog-vuepress/assets/js/36.3e108a72.js"><link rel="prefetch" href="/blog-vuepress/assets/js/37.52a93f38.js"><link rel="prefetch" href="/blog-vuepress/assets/js/38.773d206b.js"><link rel="prefetch" href="/blog-vuepress/assets/js/39.97bc89c9.js"><link rel="prefetch" href="/blog-vuepress/assets/js/4.6e64dfe5.js"><link rel="prefetch" href="/blog-vuepress/assets/js/40.d25f8604.js"><link rel="prefetch" href="/blog-vuepress/assets/js/41.42d8ab6b.js"><link rel="prefetch" href="/blog-vuepress/assets/js/43.cb86f1ad.js"><link rel="prefetch" href="/blog-vuepress/assets/js/44.510d49f7.js"><link rel="prefetch" href="/blog-vuepress/assets/js/45.8a507cdc.js"><link rel="prefetch" href="/blog-vuepress/assets/js/46.b696780b.js"><link rel="prefetch" href="/blog-vuepress/assets/js/47.fbad42a2.js"><link rel="prefetch" href="/blog-vuepress/assets/js/48.56383b2f.js"><link rel="prefetch" href="/blog-vuepress/assets/js/49.bc1afbab.js"><link rel="prefetch" href="/blog-vuepress/assets/js/5.6a73d504.js"><link rel="prefetch" href="/blog-vuepress/assets/js/50.15325e66.js"><link rel="prefetch" href="/blog-vuepress/assets/js/51.d51be4fd.js"><link rel="prefetch" href="/blog-vuepress/assets/js/52.08dcc486.js"><link rel="prefetch" href="/blog-vuepress/assets/js/53.bce9f1f4.js"><link rel="prefetch" href="/blog-vuepress/assets/js/54.555f6feb.js"><link rel="prefetch" href="/blog-vuepress/assets/js/55.d61972d7.js"><link rel="prefetch" href="/blog-vuepress/assets/js/56.eadd87e6.js"><link rel="prefetch" href="/blog-vuepress/assets/js/57.071c3d42.js"><link rel="prefetch" href="/blog-vuepress/assets/js/58.84bc7479.js"><link rel="prefetch" href="/blog-vuepress/assets/js/59.3a4ae366.js"><link rel="prefetch" href="/blog-vuepress/assets/js/6.624a029c.js"><link rel="prefetch" href="/blog-vuepress/assets/js/60.9adbe0fa.js"><link rel="prefetch" href="/blog-vuepress/assets/js/61.66e032c4.js"><link rel="prefetch" href="/blog-vuepress/assets/js/62.c290c2de.js"><link rel="prefetch" href="/blog-vuepress/assets/js/63.b0b456e0.js"><link rel="prefetch" href="/blog-vuepress/assets/js/64.aecf211c.js"><link rel="prefetch" href="/blog-vuepress/assets/js/65.8c5d3171.js"><link rel="prefetch" href="/blog-vuepress/assets/js/66.e4469d2f.js"><link rel="prefetch" href="/blog-vuepress/assets/js/67.de4ff045.js"><link rel="prefetch" href="/blog-vuepress/assets/js/68.1d85caf0.js"><link rel="prefetch" href="/blog-vuepress/assets/js/69.bec2392a.js"><link rel="prefetch" href="/blog-vuepress/assets/js/7.7c77f53c.js"><link rel="prefetch" href="/blog-vuepress/assets/js/70.2961552c.js"><link rel="prefetch" href="/blog-vuepress/assets/js/71.cde0e6cc.js"><link rel="prefetch" href="/blog-vuepress/assets/js/72.0bee0552.js"><link rel="prefetch" href="/blog-vuepress/assets/js/73.3014aed3.js"><link rel="prefetch" href="/blog-vuepress/assets/js/74.e255eaf9.js"><link rel="prefetch" href="/blog-vuepress/assets/js/75.b667279c.js"><link rel="prefetch" href="/blog-vuepress/assets/js/76.0d6de82e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/77.56abc049.js"><link rel="prefetch" href="/blog-vuepress/assets/js/78.c6531637.js"><link rel="prefetch" href="/blog-vuepress/assets/js/8.2b17cdb3.js"><link rel="prefetch" href="/blog-vuepress/assets/js/9.8488f879.js">
    <link rel="stylesheet" href="/blog-vuepress/assets/css/0.styles.63182871.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog-vuepress/" class="home-link router-link-active"><!----> <span class="site-name">U世界的V梦想</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog-vuepress/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog-vuepress/web/" class="nav-link">
  Web
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/javascript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/angular/" class="nav-link">
  Angular
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/vue/" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/vite/" class="nav-link">
  Vite
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/react/" class="nav-link">
  React
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/vue-next/" class="nav-link">
  Vue-Next
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/nodejs/" class="nav-link">
  Nodejs
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/typescript/" class="nav-link">
  Typescript
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/interview/" class="nav-link router-link-active">
  面试
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Go" class="dropdown-title"><span class="title">Go</span> <span class="arrow down"></span></button> <button type="button" aria-label="Go" class="mobile-dropdown-title"><span class="title">Go</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog-vuepress/go/" class="nav-link">
  介绍
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/go-40/" class="nav-link">
  40天
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Flutter" class="dropdown-title"><span class="title">Flutter</span> <span class="arrow down"></span></button> <button type="button" aria-label="Flutter" class="mobile-dropdown-title"><span class="title">Flutter</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog-vuepress/flutter/" class="nav-link">
  基础
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/flutter-plugin/" class="nav-link">
  插件
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/flutter-deep/" class="nav-link">
  深入
</a></li></ul></div></div><div class="nav-item"><a href="/blog-vuepress/specification/" class="nav-link">
  规范
</a></div><div class="nav-item"><a href="https://github.com/UvDream" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog-vuepress/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog-vuepress/web/" class="nav-link">
  Web
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/javascript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/angular/" class="nav-link">
  Angular
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/vue/" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/vite/" class="nav-link">
  Vite
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/react/" class="nav-link">
  React
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/vue-next/" class="nav-link">
  Vue-Next
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/nodejs/" class="nav-link">
  Nodejs
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/typescript/" class="nav-link">
  Typescript
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/interview/" class="nav-link router-link-active">
  面试
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Go" class="dropdown-title"><span class="title">Go</span> <span class="arrow down"></span></button> <button type="button" aria-label="Go" class="mobile-dropdown-title"><span class="title">Go</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog-vuepress/go/" class="nav-link">
  介绍
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/go-40/" class="nav-link">
  40天
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Flutter" class="dropdown-title"><span class="title">Flutter</span> <span class="arrow down"></span></button> <button type="button" aria-label="Flutter" class="mobile-dropdown-title"><span class="title">Flutter</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog-vuepress/flutter/" class="nav-link">
  基础
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/flutter-plugin/" class="nav-link">
  插件
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/flutter-deep/" class="nav-link">
  深入
</a></li></ul></div></div><div class="nav-item"><a href="/blog-vuepress/specification/" class="nav-link">
  规范
</a></div><div class="nav-item"><a href="https://github.com/UvDream" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>面试</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog-vuepress/interview/" aria-current="page" class="sidebar-link">前端面试</a></li><li><a href="/blog-vuepress/interview/css.html" class="sidebar-link">Css基础</a></li><li><a href="/blog-vuepress/interview/javascript.html" class="sidebar-link">/interview/javascript.html</a></li><li><a href="/blog-vuepress/interview/vue.html" aria-current="page" class="active sidebar-link">Vue 基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#vue-常用指令" class="sidebar-link">vue 常用指令</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#vue-的-mvvm" class="sidebar-link">Vue 的 MVVM</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#v-for和v-if为什么不能一起用" class="sidebar-link">v-for和v-if为什么不能一起用</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#vue-组件之间通讯" class="sidebar-link">Vue 组件之间通讯</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#vue-生命周期的理解" class="sidebar-link">vue 生命周期的理解</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#vuex-几大属性" class="sidebar-link">vuex 几大属性</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#state" class="sidebar-link">state</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#getter" class="sidebar-link">getter</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#mutation" class="sidebar-link">mutation</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#action" class="sidebar-link">action</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#vue-优点" class="sidebar-link">vue 优点</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#写-react-vue-项目时为什么要在组件中写-key-其作用是什么" class="sidebar-link">写 React / Vue 项目时为什么要在组件中写 key,其作用是什么</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#vue-的路由实现" class="sidebar-link">Vue 的路由实现</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#vue-为什么采用异步渲染" class="sidebar-link">Vue 为什么采用异步渲染</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#什么是渐进式" class="sidebar-link">什么是渐进式</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#keep-live" class="sidebar-link">keep-live</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#computed-watch-和-method" class="sidebar-link">Computed watch 和 method</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#组件中的-data-为什么是函数" class="sidebar-link">组件中的 data 为什么是函数</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#插槽与作用域插槽的区别" class="sidebar-link">插槽与作用域插槽的区别</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#vue-响应式原理" class="sidebar-link">vue 响应式原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#object-defineproperty" class="sidebar-link">Object.defineProperty</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#发布订阅模式" class="sidebar-link">发布订阅模式</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#nexttick" class="sidebar-link">nextTick</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#vue-组件渲染顺序" class="sidebar-link">Vue 组件渲染顺序</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#数据响应-数据劫持" class="sidebar-link">数据响应(数据劫持)</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#vue-如何从真实-dom-到虚拟-dom" class="sidebar-link">Vue 如何从真实 dom 到虚拟 dom</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#用-vnode-来描述一个-dom-结构" class="sidebar-link">用 VNode 来描述一个 dom 结构</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#virtual-dom-原理实现" class="sidebar-link">virtual dom 原理实现</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#proxy-相比于-defineproperty-的优势" class="sidebar-link">Proxy 相比于 defineProperty 的优势</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#vue-router-有哪几种导航守卫" class="sidebar-link">vue-router 有哪几种导航守卫?</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#vue-为什么用-function-实现类-而不是-es6-的-class" class="sidebar-link">Vue 为什么用 function 实现类,而不是 ES6 的 class</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/interview/vue.html#vue3-的优点" class="sidebar-link">vue3 的优点</a></li></ul></li><li><a href="/blog-vuepress/interview/typescript.html" class="sidebar-link">Typescript</a></li><li><a href="/blog-vuepress/interview/react.html" class="sidebar-link">React</a></li><li><a href="/blog-vuepress/interview/code.html" class="sidebar-link">常见代码</a></li><li><a href="/blog-vuepress/interview/type.html" class="sidebar-link">基本数据类型</a></li><li><a href="/blog-vuepress/interview/http.html" class="sidebar-link">HTTP</a></li><li><a href="/blog-vuepress/interview/catch.html" class="sidebar-link">浏览器缓存</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue-基础"><a href="#vue-基础" class="header-anchor">#</a> Vue 基础</h1> <h2 id="vue-常用指令"><a href="#vue-常用指令" class="header-anchor">#</a> vue 常用指令</h2> <details><p>span</p> <pre><code>v-if v-show v-bind(:) v-for v-model  v-text v-html v-on(@)

</code></pre></details> <h6 id="mvc"><a href="#mvc" class="header-anchor">#</a> MVC</h6> <p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020105.png" alt="MVC"></p> <details><summary>答案</summary> <pre><code>1. View 传送指令到 Controller


2. Controller 完成业务逻辑后,要求 Model 改变状态


3. Model 将新的数据发送到 View,用户得到反馈

   </code></pre></details> <h2 id="vue-的-mvvm"><a href="#vue-的-mvvm" class="header-anchor">#</a> Vue 的 MVVM</h2> <details><summary>答案</summary> <p>MVVM 全称是 Model-View-ViewModel,Vue 是以数据驱动的,一旦 dom 创建,数据更新 dom 也就跟着更新</p> <p>1、M 就是 Model 模型层,存的一个数据对象.</p> <p>2、V 就是 View 视图层,所有的 html 节点在这一层.</p> <p>3、VM 就是 ViewModel,它通过 data 属性连接 Model 模型层,通过 el 属性连接 View 视图层</p></details> <h2 id="v-for和v-if为什么不能一起用"><a href="#v-for和v-if为什么不能一起用" class="header-anchor">#</a> <code>v-for</code>和<code>v-if</code>为什么不能一起用</h2> <details><summary>答案</summary> <ul><li><code>v-for</code> 会比<code>v-if</code> 的优先级更高，连用的话会把<code>v-if</code> 的每个元素都添加一下，造成性能问题。</li></ul></details> <h2 id="vue-组件之间通讯"><a href="#vue-组件之间通讯" class="header-anchor">#</a> Vue 组件之间通讯</h2> <details><summary>答案</summary> <ul><li>父子间通信:父亲提供数据通过属性<code>props</code>传给儿子；儿子通过<code>$on</code> 绑父亲的事件，再通过<code>$emit</code> 触发自己的事件（发布订阅）</li> <li>利用父子关系<code>$parent</code> 、<code>$children</code> ，</li></ul> <p>获取父子组件实例的方法。</p> <ul><li>父组件提供数据，子组件注入。<code>provide</code> 、<code>inject</code> ，插件用得多。</li> <li><code>ref</code> 获取组件实例，调用组件的属性、方法</li> <li>跨组件通信<code>Event Bus</code> （Vue.prototype.bus=newVue）其实基于 bus = new Vue）其实基于 bus=newVue）其实基于 on 与$emit</li> <li><code>vuex</code> 状态管理实现通信</li></ul></details> <h2 id="vue-生命周期的理解"><a href="#vue-生命周期的理解" class="header-anchor">#</a> vue 生命周期的理解</h2> <details><summary>答案</summary> <p>创建前/后,载入前/后,更新前/后,销毁前/后</p> <p>它的生命周期中有多个事件钩子,让我们在控制整个 Vue 实例的过程时更容易形成好的逻辑.</p> <ul><li><p>beforeCreated() 在实例创建之间执行,数据未加载状态</p></li> <li><p>created() 在实例创建、数据加载后,能初始化数据,dom 渲染之前执行</p></li> <li><p>beforeMount() 虚拟 dom 已创建完成,在数据渲染前最后一次更改数据</p></li> <li><p>mounted() 页面、数据渲染完成,真实 dom 挂载完成</p></li> <li><p>beforeUpadate() 重新渲染之前触发</p></li> <li><p>updated() 数据已经更改完成,dom 也重新 render 完成,更改数据会陷入死循环</p></li> <li><p>beforeDestory() 和 destoryed() 前者是销毁前执行（实例仍然完全可用）,后者则是销毁后执行</p></li></ul></details> <h2 id="vuex-几大属性"><a href="#vuex-几大属性" class="header-anchor">#</a> vuex 几大属性</h2> <details><summary>答案</summary> <pre><code>有五种,分别是 State、 Getter、Mutation 、Action、 Module
  </code></pre></details> <h2 id="state"><a href="#state" class="header-anchor">#</a> state</h2> <details><summary>答案</summary> <p>1、Vuex 就是一个仓库,仓库里面放了很多对象.其中 state 就是数据源存放地,对应于与一般 Vue 对象里面的 data</p> <p>2、state 里面存放的数据是响应式的,Vue 组件从 store 中读取数据,若是 store 中的数据发生改变,依赖这个数据的组件也会发生更新</p> <p>3、它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性中</p></details> <h2 id="getter"><a href="#getter" class="header-anchor">#</a> getter</h2> <details><summary>答案</summary> <p>1、Vuex 就是一个仓库,仓库里面放了很多对象.其中 state 就是数据源存放地,对应于与一般 Vue 对象里面的 data</p> <p>2、state 里面存放的数据是响应式的,Vue 组件从 store 中读取数据,若是 store 中的数据发生改变,依赖这个数据的组件也会发生更新</p> <p>3、它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性中</p></details> <h2 id="mutation"><a href="#mutation" class="header-anchor">#</a> mutation</h2> <details><summary>答案</summary> <p>mutations 定义的方法动态修改 Vuex 的 store 中的状态或数据.</p></details> <h2 id="action"><a href="#action" class="header-anchor">#</a> action</h2> <details><summary>答案</summary> <p>action 类似于 mutation,不同在于：</p> <ul><li><p>action 提交的是 mutation,而不是直接变更状态.</p></li> <li><p>action 可以包含任意异步操作</p></li></ul></details> <h2 id="vue-优点"><a href="#vue-优点" class="header-anchor">#</a> vue 优点</h2> <details><summary>答案</summary> <p>低耦合.视图（View）可以独立于 Model 变化和修改,一个 ViewModel 可以绑定到不同的&quot;View&quot;上,当 View 变化的时候 Model 可以不变,当 Model 变化的时候 View 也可以不变.</p> <p>可重用性.你可以把一些视图逻辑放在一个 ViewModel 里面,让很多 view 重用这段视图逻辑.</p> <p>独立开发.开发人员可以专注于业务逻辑和数据的开发（ViewModel）,设计人员可以专注于页面设计,使用 Expression Blend 可以很容易设计界面并生成 xml 代码.</p></details> <h2 id="写-react-vue-项目时为什么要在组件中写-key-其作用是什么"><a href="#写-react-vue-项目时为什么要在组件中写-key-其作用是什么" class="header-anchor">#</a> 写 React / Vue 项目时为什么要在组件中写 key,其作用是什么</h2> <details><summary>答案</summary> <p>key 的作用是为了在 diff 算法执行时更快的找到对应的节点,提高 diff 速度</p></details> <h2 id="vue-的路由实现"><a href="#vue-的路由实现" class="header-anchor">#</a> Vue 的路由实现</h2> <details><summary>答案</summary> <p>hash 模式 和 history 模式</p></details> <h1 id="vue-深入"><a href="#vue-深入" class="header-anchor">#</a> Vue 深入</h1> <h2 id="vue-为什么采用异步渲染"><a href="#vue-为什么采用异步渲染" class="header-anchor">#</a> Vue 为什么采用异步渲染</h2> <details><summary>答案</summary> <p><code>Vue</code> 是组件级更新，如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以为了性能，<code>Vue</code> 会在本轮数据更新后，在异步更新视图。核心思想 <code>nextTick</code> 。</p> <p><code>dep.notify（）</code> 通知 watcher 进行更新，<code>subs[i].update</code> 依次调用 watcher 的 <code>update</code> ，<code>queueWatcher</code> 将 watcher 去重放入队列， nextTick（<code>flushSchedulerQueue</code> ）在下一 tick 中刷新 watcher 队列（异步）。</p></details> <h2 id="什么是渐进式"><a href="#什么是渐进式" class="header-anchor">#</a> 什么是渐进式</h2> <details><summary>答案</summary> <p>简单的来说就是把框架分层,还有一种理解,如果你有一个现成的服务端应用,也就是非单页应用,可以将 Vuejs 作为该应用的一部分嵌入其中,带来更多的丰富的交互体验</p></details> <h2 id="keep-live"><a href="#keep-live" class="header-anchor">#</a> keep-live</h2> <details><summary>答案</summary> <p>把切换出去的组件保留在缓存中,可以保留组件的状态或者避免重新渲染</p></details> <h2 id="computed-watch-和-method"><a href="#computed-watch-和-method" class="header-anchor">#</a> Computed watch 和 method</h2> <details><summary>答案</summary>
computed：默认computed也是一个watcher具备缓存，只有当依赖的数据变化时才会计算, 当数据没有变化时, 它会读取缓存数据。如果一个数据依赖于其他数据，使用 computed
watch：每次都需要执行函数。  watch 更适用于数据变化时的异步操作。如果需要在某个数据变化时做一些事情，使用watch。
method：只要把方法用到模板上了,每次一变化就会重新渲染视图，性能开销大
</details> <h2 id="组件中的-data-为什么是函数"><a href="#组件中的-data-为什么是函数" class="header-anchor">#</a> 组件中的 data 为什么是函数</h2> <details><summary>答案</summary>
避免组件中的数据互相影响。同一个组件被复用多次会创建多个实例，如果 data 是一个对象的话，这些实例用的是同一个构造函数。为了保证组件的数据独立，要求每个组件都必须通过 data 函数返回一个对象作为组件的状态。
</details> <h2 id="插槽与作用域插槽的区别"><a href="#插槽与作用域插槽的区别" class="header-anchor">#</a> 插槽与作用域插槽的区别</h2> <blockquote><p>插槽</p></blockquote> <details><summary>答案</summary>
- 创建组件虚拟节点时，会将组件儿子的虚拟节点保存起来。当初始化组件时，通过插槽属性将儿子进行分类 {a:[vnode],b[vnode]}
- 渲染组件时会拿对应的 slot 属性的节点进行替换操作。（插槽的作用域为父组件）
</details> <blockquote><p>作用域插槽</p></blockquote> <details><summary>答案</summary>
- 作用域插槽在解析的时候不会作为组件的孩子节点。会解析成函数，当子组件渲染时，会调用此函数进行渲染。
- 普通插槽渲染的作用域是父组件，作用域插槽的渲染作用域是当前子组件。
</details> <h2 id="vue-响应式原理"><a href="#vue-响应式原理" class="header-anchor">#</a> vue 响应式原理</h2> <h3 id="object-defineproperty"><a href="#object-defineproperty" class="header-anchor">#</a> Object.defineProperty</h3> <details><summary>答案</summary> <p>首先我们想到的是 Object.defineProperty,这是 es5 新增的一个 api,它可以允许我们为对象的属性来设定 getter 和 setter,从而我们可以劫持用户对对象属性的取值和赋值.比如以下代码:</p> <pre><code>const obj = {};


let val = &quot;cjg&quot;;

Object.defineProperty(obj, &quot;name&quot;, {

get() {

console.log(&quot;劫持了你的取值操作啦&quot;);

return val;

},

set(newVal) {

console.log(&quot;劫持了你的赋值操作啦&quot;);

val = newVal;

},

});


console.log(obj.name);

obj.name = &quot;cwc&quot;;

console.log(obj.name);

</code></pre> <p>我们通过 Object.defineProperty 劫持了 obj[name]的取值和赋值操作,因此我们就可以在这里做一些手脚啦,比如说,我们可以在 obj[name]被赋值的时候触发更新页面操作.</p></details> <h3 id="发布订阅模式"><a href="#发布订阅模式" class="header-anchor">#</a> 发布订阅模式</h3> <details><summary>答案</summary> <p>发布订阅模式是设计模式中比较常见的一种,其中有两个角色：发布者和订阅者.多个订阅者可以向同一发布者订阅一个事件,当事件发生的时候,发布者通知所有订阅该事件的订阅者.我们来看一个例子了解下.</p> <pre><code>class Dep {

  constructor() {

    this.subs = [];

  }

  // 增加订阅者

  addSub(sub) {

    if (this.subs.indexOf(sub) &lt; 0) {
  
      this.subs.push(sub);
  
    }

  }

  // 通知订阅者

  notify() {

    this.subs.forEach((sub) =&gt; {
  
      sub.update();
  
    });

  }

}


const dep = new Dep();


const sub = {

update() {

console.log(&quot;sub1 update&quot;);

},

};


const sub1 = {

update() {

console.log(&quot;sub2 update&quot;);

},

};


dep.addSub(sub);

dep.addSub(sub1);

dep.notify(); //

</code></pre> <ul><li>vue.js 首先通过 Object.defineProperty 来对要监听的数据进行 getter 和 setter 劫持,当数据的属性被赋值/取值的时候,vue.js 就可以察觉到并做相应的处理.</li> <li>通过订阅发布模式,我们可以为对象的每个属性都创建一个发布者,当有其他订阅者依赖于这个属性的时候,则将订阅者加入到发布者的队列中.利用 Object.defineProperty 的数据劫持,在属性的 setter 调用的时候,该属性的发布者通知所有订阅者更新内容.</li></ul></details> <h2 id="nexttick"><a href="#nexttick" class="header-anchor">#</a> nextTick</h2> <details><summary>答案</summary> <p>异步方法，异步渲染最后一步，与 <code>JS</code>事件循环联系紧密。主要使用了宏任务微任务（<code>setTimeout</code>、<code>promise</code>那些），定义了一个异步方法，多次调用 <code>nextTick</code>会将方法存入队列，通过异步方法清空当前队列。</p></details> <h2 id="vue-组件渲染顺序"><a href="#vue-组件渲染顺序" class="header-anchor">#</a> Vue 组件渲染顺序</h2> <details><summary>答案</summary>
渲染顺序：先父后子，完成顺序：先子后父
<p>更新顺序：父更新导致子更新，子更新完成后父</p> <p>销毁顺序：先父后子，完成顺序：先子后父</p></details> <h2 id="数据响应-数据劫持"><a href="#数据响应-数据劫持" class="header-anchor">#</a> 数据响应(数据劫持)</h2> <details><summary>答案</summary> <p>看完生命周期后,里面的 watcher 等内容其实是数据响应中的一部分.数据响应的实现由两部分构成: 观察者( watcher ) 和 依赖收集器( Dep ),其核心是 defineProperty 这个方法,它可以 重写属性的 get 与 set 方法,从而完成监听数据的改变.</p> <ul><li><p>Observe (观察者)观察 props 与 state</p> <ul><li>遍历 props 与 state,对每个属性创建独立的监听器( watcher )</li></ul></li></ul> <ul><li><p>使用 defineProperty 重写每个属性的 get/set(defineReactive）</p> <ul><li><p>get: 收集依赖</p> <ul><li><p>Dep.depend()</p> <ul><li>watcher.addDep()</li></ul></li></ul></li> <li><p>set: 派发更新</p> <ul><li>Dep.notify()</li> <li>watcher.update()</li> <li>queenWatcher()</li> <li>nextTick</li> <li>flushScheduleQueue</li> <li>watcher.run()</li> <li>updateComponent()</li></ul></li></ul></li></ul> <pre><code>let data = { a: 1 };

// 数据响应性

observe(data);


// 初始化观察者

new Watcher(data, &quot;name&quot;, updateComponent);

data.a = 2;


// 简单表示用于数据更新后的操作

function updateComponent() {

  vm._update(); // patchs

}


// 监视对象

function observe(obj) {

  // 遍历对象,使用 get/set 重新定义对象的每个属性值

  Object.keys(obj).map((key) =&gt; {

    defineReactive(obj, key, obj[key]);

  });

}


function defineReactive(obj, k, v) {

  // 递归子属性

  if (type(v) == &quot;object&quot;) observe(v);


  // 新建依赖收集器

  let dep = new Dep();

  // 定义get/set

  Object.defineProperty(obj, k, {

    enumerable: true,
  
    configurable: true,
  
    get: function reactiveGetter() {
  
      // 当有获取该属性时,证明依赖于该对象,因此被添加进收集器中
  
      if (Dep.target) {
  
        dep.addSub(Dep.target);
  
      }
  
      return v;
  
    },
  
    // 重新设置值时,触发收集器的通知机制
  
    set: function reactiveSetter(nV) {
  
      v = nV;
  
      dep.nofify();
  
    },

  });

}


// 依赖收集器

class Dep {

  constructor() {

    this.subs = [];

  }

  addSub(sub) {

    this.subs.push(sub);

  }

  notify() {

    this.subs.map((sub) =&gt; {
  
      sub.update();
  
    });

  }

}


Dep.target = null;


// 观察者

class Watcher {

  constructor(obj, key, cb) {

    Dep.target = this;
  
    this.cb = cb;
  
    this.obj = obj;
  
    this.key = key;
  
    this.value = obj[key];
  
    Dep.target = null;

  }

  addDep(Dep) {

    Dep.addSub(this);

  }

  update() {

    this.value = this.obj[this.key];
  
    this.cb(this.value);

  }

  before() {

    callHook(&quot;beforeUpdate&quot;);

  }

}

  </code></pre></details> <h2 id="vue-如何从真实-dom-到虚拟-dom"><a href="#vue-如何从真实-dom-到虚拟-dom" class="header-anchor">#</a> Vue 如何从真实 dom 到虚拟 dom</h2> <details><summary>答案</summary>
涉及到Vue中的模板编译原理，主要过程：
<p>将模板转换成 <code>ast</code> 树， <code>ast</code> 用对象来描述真实的 <code>JS</code>语法（将真实 <code>DOM</code>转换成虚拟 <code>DOM</code>）</p> <p>优化树</p> <p>将 <code>ast</code> 树生成代码</p></details> <h2 id="用-vnode-来描述一个-dom-结构"><a href="#用-vnode-来描述一个-dom-结构" class="header-anchor">#</a> 用 VNode 来描述一个 dom 结构</h2> <details><summary>答案</summary>
涉及到Vue中的模板编译原理，主要过程：
虚拟节点就是用一个对象来描述一个真实的DOM元素。首先将` template` （真实DOM）先转成` ast` ，` ast` 树通过` codegen` 生成` render` 函数，` render` 函数里的` _c` 方法将它转为虚拟dom
</details> <h2 id="virtual-dom-原理实现"><a href="#virtual-dom-原理实现" class="header-anchor">#</a> virtual dom 原理实现</h2> <details><summary>答案</summary> <ul><li><p>创建 dom 树</p></li> <li><p>树的 diff,同层对比,输出 patchs(listDiff/diffChildren/diffProps)</p> <ul><li><p>没有新的节点,返回</p></li> <li><p>新的节点 tagName 与 key 不变, 对比 props,继续递归遍历子树</p> <ul><li><p>对比属性(对比新旧属性列表):</p> <ul><li>旧属性是否存在与新属性列表中</li> <li>都存在的是否有变化</li> <li>是否出现旧列表中没有的新属性</li></ul></li> <li><p>tagName 和 key 值变化了,则直接替换成新节点</p></li></ul></li></ul></li> <li><p>渲染差异</p> <ul><li>遍历 patchs, 把需要更改的节点取出来</li> <li>局部更新 dom</li></ul></li></ul> <pre><code>// diff算法的实现

function diff(oldTree, newTree) {

  // 差异收集

  let pathchs = {};

  dfs(oldTree, newTree, 0, pathchs);

  return pathchs;

}


function dfs(oldNode, newNode, index, pathchs) {

let curPathchs = [];

if (newNode) {

// 当新旧节点的 tagName 和 key 值完全一致时

if (oldNode.tagName === newNode.tagName &amp;&amp; oldNode.key === newNode.key) {

// 继续比对属性差异

let props = diffProps(oldNode.props, newNode.props);

curPathchs.push({ type: &quot;changeProps&quot;, props });

// 递归进入下一层级的比较

diffChildrens(oldNode.children, newNode.children, index, pathchs);

} else {

// 当 tagName 或者 key 修改了后,表示已经是全新节点,无需再比

curPathchs.push({ type: &quot;replaceNode&quot;, node: newNode });

}

}


// 构建出整颗差异树

if (curPathchs.length) {

if (pathchs[index]) {

pathchs[index] = pathchs[index].concat(curPathchs);

} else {

pathchs[index] = curPathchs;

}

}

}


// 属性对比实现

function diffProps(oldProps, newProps) {

let propsPathchs = [];

// 遍历新旧属性列表

// 查找删除项

// 查找修改项

// 查找新增项 mutation

forin(olaProps, (k, v) =&gt; {

if (!newProps.hasOwnProperty(k)) {

propsPathchs.push({ type: &quot;remove&quot;, prop: k });

} else {

if (v !== newProps[k]) {

propsPathchs.push({ type: &quot;change&quot;, prop: k, value: newProps[k] });

}

}

});

forin(newProps, (k, v) =&gt; {

if (!oldProps.hasOwnProperty(k)) {

propsPathchs.push({ type: &quot;add&quot;, prop: k, value: v });

}

});

return propsPathchs;

}


// 对比子级差异

function diffChildrens(oldChild, newChild, index, pathchs) {

// 标记子级的删除/新增/移动

let { change, list } = diffList(oldChild, newChild, index, pathchs);

if (change.length) {

if (pathchs[index]) {

pathchs[index] = pathchs[index].concat(change);

} else {

pathchs[index] = change;

}

}


// 根据 key 获取原本匹配的节点,进一步递归从头开始对比

oldChild.map((item, i) =&gt; {

let keyIndex = list.indexOf(item.key);

if (keyIndex) {

let node = newChild[keyIndex];

// 进一步递归对比

dfs(item, node, index, pathchs);

}

});

}


// 列表对比,主要也是根据 key 值查找匹配项

// 对比出新旧列表的新增/删除/移动

function diffList(oldList, newList, index, pathchs) {

let change = [];

let list = [];

const newKeys = getKey(newList);

oldList.map((v) =&gt; {

if (newKeys.indexOf(v.key) &gt; -1) {

list.push(v.key);

} else {

list.push(null);

}

});


// 标记删除

for (let i = list.length - 1; i &gt;= 0; i--) {

if (!list[i]) {

list.splice(i, 1);

change.push({ type: &quot;remove&quot;, index: i });

}

}


// 标记新增和移动

newList.map((item, i) =&gt; {

const key = item.key;

const index = list.indexOf(key);

if (index === -1 || key == null) {

// 新增

change.push({ type: &quot;add&quot;, node: item, index: i });

list.splice(i, 0, key);

} else {

// 移动

if (index !== i) {

change.push({

type: &quot;move&quot;,

form: index,

to: i,

});

move(list, index, i);

}

}

});


return { change, list };

}

</code></pre></details> <h2 id="proxy-相比于-defineproperty-的优势"><a href="#proxy-相比于-defineproperty-的优势" class="header-anchor">#</a> Proxy 相比于 defineProperty 的优势</h2> <details><summary>答案</summary> <ul><li>数组变化也能监听到</li> <li>不需要深度遍历监听</li></ul></details> <h2 id="vue-router-有哪几种导航守卫"><a href="#vue-router-有哪几种导航守卫" class="header-anchor">#</a> vue-router 有哪几种导航守卫?</h2> <details><summary>答案</summary> <ul><li>全局守卫</li> <li>路由独享守卫</li> <li>路由组件内的守卫</li></ul></details> <h2 id="vue-为什么用-function-实现类-而不是-es6-的-class"><a href="#vue-为什么用-function-实现类-而不是-es6-的-class" class="header-anchor">#</a> Vue 为什么用 function 实现类,而不是 ES6 的 class</h2> <details><summary>答案</summary> <p>很多的 mixin 的函数调用,把 Vue 当参数传入,它的功能个都是给 VUe 的 prototype 上扩展一些方法,Vue 按功能把这些扩展分散到多个模块中去实现,而不是一个模块实现所有,这种方式 Class 是很难实现的,这么做的好处是非常方便代码的维护和管理</p> <p>在 Vue3 中使用 Function-base API</p> <p>对比 Class API</p> <ul><li><p>更灵活的逻辑复用能力</p></li> <li><p>更好的 TypeScript 类型推到支持</p></li> <li><p>更好的性能</p></li> <li><p>Tree-shaking 友好</p></li> <li><p>代码更容易被压缩</p></li></ul></details> <h2 id="vue3-的优点"><a href="#vue3-的优点" class="header-anchor">#</a> vue3 的优点</h2> <details><summary>答案</summary> <ul><li>更小</li></ul> <blockquote><p>移除了一些不常用的 API,引入了 tree-shaking</p></blockquote> <ul><li>更快</li></ul> <blockquote><p>diff 算法优化</p></blockquote> <blockquote><p>静态提升</p></blockquote> <blockquote><p>事件监听缓存</p></blockquote> <blockquote><p>SSR 优化</p></blockquote> <ul><li>TypeScript 支持</li> <li>API 设计一致性</li> <li>提升自身可维护性</li> <li>开放更多的底层功能</li></ul></details></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新时间:</span> <span class="time">2/22/2021, 3:30:54 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog-vuepress/interview/javascript.html" class="prev">
        /interview/javascript.html
      </a></span> <span class="next"><a href="/blog-vuepress/interview/typescript.html">
        Typescript
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/blog-vuepress/assets/js/app.4535e051.js" defer></script><script src="/blog-vuepress/assets/js/2.778d2fa8.js" defer></script><script src="/blog-vuepress/assets/js/42.4608b0fe.js" defer></script>
  </body>
</html>
