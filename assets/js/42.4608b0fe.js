(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{458:function(e,n,t){"use strict";t.r(n);var v=t(25),a=Object(v.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"vue-基础"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-基础"}},[e._v("#")]),e._v(" Vue 基础")]),e._v(" "),t("h2",{attrs:{id:"vue-常用指令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-常用指令"}},[e._v("#")]),e._v(" vue 常用指令")]),e._v(" "),t("details",[t("p",[e._v("span")]),e._v(" "),t("pre",[t("code",[e._v("v-if v-show v-bind(:) v-for v-model  v-text v-html v-on(@)\n\n")])])]),e._v(" "),t("h6",{attrs:{id:"mvc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mvc"}},[e._v("#")]),e._v(" MVC")]),e._v(" "),t("p",[t("img",{attrs:{src:"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020105.png",alt:"MVC"}})]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v(" "),t("pre",[t("code",[e._v("1. View 传送指令到 Controller\n\n\n2. Controller 完成业务逻辑后,要求 Model 改变状态\n\n\n3. Model 将新的数据发送到 View,用户得到反馈\n\n   ")])])]),e._v(" "),t("h2",{attrs:{id:"vue-的-mvvm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-的-mvvm"}},[e._v("#")]),e._v(" Vue 的 MVVM")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v(" "),t("p",[e._v("MVVM 全称是 Model-View-ViewModel,Vue 是以数据驱动的,一旦 dom 创建,数据更新 dom 也就跟着更新")]),e._v(" "),t("p",[e._v("1、M 就是 Model 模型层,存的一个数据对象.")]),e._v(" "),t("p",[e._v("2、V 就是 View 视图层,所有的 html 节点在这一层.")]),e._v(" "),t("p",[e._v("3、VM 就是 ViewModel,它通过 data 属性连接 Model 模型层,通过 el 属性连接 View 视图层")])]),e._v(" "),t("h2",{attrs:{id:"v-for和v-if为什么不能一起用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v-for和v-if为什么不能一起用"}},[e._v("#")]),e._v(" "),t("code",[e._v("v-for")]),e._v("和"),t("code",[e._v("v-if")]),e._v("为什么不能一起用")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("v-for")]),e._v(" 会比"),t("code",[e._v("v-if")]),e._v(" 的优先级更高，连用的话会把"),t("code",[e._v("v-if")]),e._v(" 的每个元素都添加一下，造成性能问题。")])])]),e._v(" "),t("h2",{attrs:{id:"vue-组件之间通讯"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-组件之间通讯"}},[e._v("#")]),e._v(" Vue 组件之间通讯")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v(" "),t("ul",[t("li",[e._v("父子间通信:父亲提供数据通过属性"),t("code",[e._v("props")]),e._v("传给儿子；儿子通过"),t("code",[e._v("$on")]),e._v(" 绑父亲的事件，再通过"),t("code",[e._v("$emit")]),e._v(" 触发自己的事件（发布订阅）")]),e._v(" "),t("li",[e._v("利用父子关系"),t("code",[e._v("$parent")]),e._v(" 、"),t("code",[e._v("$children")]),e._v(" ，")])]),e._v(" "),t("p",[e._v("获取父子组件实例的方法。")]),e._v(" "),t("ul",[t("li",[e._v("父组件提供数据，子组件注入。"),t("code",[e._v("provide")]),e._v(" 、"),t("code",[e._v("inject")]),e._v(" ，插件用得多。")]),e._v(" "),t("li",[t("code",[e._v("ref")]),e._v(" 获取组件实例，调用组件的属性、方法")]),e._v(" "),t("li",[e._v("跨组件通信"),t("code",[e._v("Event Bus")]),e._v(" （Vue.prototype.bus=newVue）其实基于 bus = new Vue）其实基于 bus=newVue）其实基于 on 与$emit")]),e._v(" "),t("li",[t("code",[e._v("vuex")]),e._v(" 状态管理实现通信")])])]),e._v(" "),t("h2",{attrs:{id:"vue-生命周期的理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-生命周期的理解"}},[e._v("#")]),e._v(" vue 生命周期的理解")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v(" "),t("p",[e._v("创建前/后,载入前/后,更新前/后,销毁前/后")]),e._v(" "),t("p",[e._v("它的生命周期中有多个事件钩子,让我们在控制整个 Vue 实例的过程时更容易形成好的逻辑.")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("beforeCreated() 在实例创建之间执行,数据未加载状态")])]),e._v(" "),t("li",[t("p",[e._v("created() 在实例创建、数据加载后,能初始化数据,dom 渲染之前执行")])]),e._v(" "),t("li",[t("p",[e._v("beforeMount() 虚拟 dom 已创建完成,在数据渲染前最后一次更改数据")])]),e._v(" "),t("li",[t("p",[e._v("mounted() 页面、数据渲染完成,真实 dom 挂载完成")])]),e._v(" "),t("li",[t("p",[e._v("beforeUpadate() 重新渲染之前触发")])]),e._v(" "),t("li",[t("p",[e._v("updated() 数据已经更改完成,dom 也重新 render 完成,更改数据会陷入死循环")])]),e._v(" "),t("li",[t("p",[e._v("beforeDestory() 和 destoryed() 前者是销毁前执行（实例仍然完全可用）,后者则是销毁后执行")])])])]),e._v(" "),t("h2",{attrs:{id:"vuex-几大属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vuex-几大属性"}},[e._v("#")]),e._v(" vuex 几大属性")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v(" "),t("pre",[t("code",[e._v("有五种,分别是 State、 Getter、Mutation 、Action、 Module\n  ")])])]),e._v(" "),t("h2",{attrs:{id:"state"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#state"}},[e._v("#")]),e._v(" state")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v(" "),t("p",[e._v("1、Vuex 就是一个仓库,仓库里面放了很多对象.其中 state 就是数据源存放地,对应于与一般 Vue 对象里面的 data")]),e._v(" "),t("p",[e._v("2、state 里面存放的数据是响应式的,Vue 组件从 store 中读取数据,若是 store 中的数据发生改变,依赖这个数据的组件也会发生更新")]),e._v(" "),t("p",[e._v("3、它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性中")])]),e._v(" "),t("h2",{attrs:{id:"getter"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#getter"}},[e._v("#")]),e._v(" getter")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v(" "),t("p",[e._v("1、Vuex 就是一个仓库,仓库里面放了很多对象.其中 state 就是数据源存放地,对应于与一般 Vue 对象里面的 data")]),e._v(" "),t("p",[e._v("2、state 里面存放的数据是响应式的,Vue 组件从 store 中读取数据,若是 store 中的数据发生改变,依赖这个数据的组件也会发生更新")]),e._v(" "),t("p",[e._v("3、它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性中")])]),e._v(" "),t("h2",{attrs:{id:"mutation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mutation"}},[e._v("#")]),e._v(" mutation")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v(" "),t("p",[e._v("mutations 定义的方法动态修改 Vuex 的 store 中的状态或数据.")])]),e._v(" "),t("h2",{attrs:{id:"action"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#action"}},[e._v("#")]),e._v(" action")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v(" "),t("p",[e._v("action 类似于 mutation,不同在于：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("action 提交的是 mutation,而不是直接变更状态.")])]),e._v(" "),t("li",[t("p",[e._v("action 可以包含任意异步操作")])])])]),e._v(" "),t("h2",{attrs:{id:"vue-优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-优点"}},[e._v("#")]),e._v(" vue 优点")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v(" "),t("p",[e._v('低耦合.视图（View）可以独立于 Model 变化和修改,一个 ViewModel 可以绑定到不同的"View"上,当 View 变化的时候 Model 可以不变,当 Model 变化的时候 View 也可以不变.')]),e._v(" "),t("p",[e._v("可重用性.你可以把一些视图逻辑放在一个 ViewModel 里面,让很多 view 重用这段视图逻辑.")]),e._v(" "),t("p",[e._v("独立开发.开发人员可以专注于业务逻辑和数据的开发（ViewModel）,设计人员可以专注于页面设计,使用 Expression Blend 可以很容易设计界面并生成 xml 代码.")])]),e._v(" "),t("h2",{attrs:{id:"写-react-vue-项目时为什么要在组件中写-key-其作用是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#写-react-vue-项目时为什么要在组件中写-key-其作用是什么"}},[e._v("#")]),e._v(" 写 React / Vue 项目时为什么要在组件中写 key,其作用是什么")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v(" "),t("p",[e._v("key 的作用是为了在 diff 算法执行时更快的找到对应的节点,提高 diff 速度")])]),e._v(" "),t("h2",{attrs:{id:"vue-的路由实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-的路由实现"}},[e._v("#")]),e._v(" Vue 的路由实现")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v(" "),t("p",[e._v("hash 模式 和 history 模式")])]),e._v(" "),t("h1",{attrs:{id:"vue-深入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-深入"}},[e._v("#")]),e._v(" Vue 深入")]),e._v(" "),t("h2",{attrs:{id:"vue-为什么采用异步渲染"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-为什么采用异步渲染"}},[e._v("#")]),e._v(" Vue 为什么采用异步渲染")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v(" "),t("p",[t("code",[e._v("Vue")]),e._v(" 是组件级更新，如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以为了性能，"),t("code",[e._v("Vue")]),e._v(" 会在本轮数据更新后，在异步更新视图。核心思想 "),t("code",[e._v("nextTick")]),e._v(" 。")]),e._v(" "),t("p",[t("code",[e._v("dep.notify（）")]),e._v(" 通知 watcher 进行更新，"),t("code",[e._v("subs[i].update")]),e._v(" 依次调用 watcher 的 "),t("code",[e._v("update")]),e._v(" ，"),t("code",[e._v("queueWatcher")]),e._v(" 将 watcher 去重放入队列， nextTick（"),t("code",[e._v("flushSchedulerQueue")]),e._v(" ）在下一 tick 中刷新 watcher 队列（异步）。")])]),e._v(" "),t("h2",{attrs:{id:"什么是渐进式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是渐进式"}},[e._v("#")]),e._v(" 什么是渐进式")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v(" "),t("p",[e._v("简单的来说就是把框架分层,还有一种理解,如果你有一个现成的服务端应用,也就是非单页应用,可以将 Vuejs 作为该应用的一部分嵌入其中,带来更多的丰富的交互体验")])]),e._v(" "),t("h2",{attrs:{id:"keep-live"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#keep-live"}},[e._v("#")]),e._v(" keep-live")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v(" "),t("p",[e._v("把切换出去的组件保留在缓存中,可以保留组件的状态或者避免重新渲染")])]),e._v(" "),t("h2",{attrs:{id:"computed-watch-和-method"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#computed-watch-和-method"}},[e._v("#")]),e._v(" Computed watch 和 method")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v("\ncomputed：默认computed也是一个watcher具备缓存，只有当依赖的数据变化时才会计算, 当数据没有变化时, 它会读取缓存数据。如果一个数据依赖于其他数据，使用 computed\nwatch：每次都需要执行函数。  watch 更适用于数据变化时的异步操作。如果需要在某个数据变化时做一些事情，使用watch。\nmethod：只要把方法用到模板上了,每次一变化就会重新渲染视图，性能开销大\n")]),e._v(" "),t("h2",{attrs:{id:"组件中的-data-为什么是函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件中的-data-为什么是函数"}},[e._v("#")]),e._v(" 组件中的 data 为什么是函数")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v("\n避免组件中的数据互相影响。同一个组件被复用多次会创建多个实例，如果 data 是一个对象的话，这些实例用的是同一个构造函数。为了保证组件的数据独立，要求每个组件都必须通过 data 函数返回一个对象作为组件的状态。\n")]),e._v(" "),t("h2",{attrs:{id:"插槽与作用域插槽的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#插槽与作用域插槽的区别"}},[e._v("#")]),e._v(" 插槽与作用域插槽的区别")]),e._v(" "),t("blockquote",[t("p",[e._v("插槽")])]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v("\n- 创建组件虚拟节点时，会将组件儿子的虚拟节点保存起来。当初始化组件时，通过插槽属性将儿子进行分类 {a:[vnode],b[vnode]}\n- 渲染组件时会拿对应的 slot 属性的节点进行替换操作。（插槽的作用域为父组件）\n")]),e._v(" "),t("blockquote",[t("p",[e._v("作用域插槽")])]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v("\n- 作用域插槽在解析的时候不会作为组件的孩子节点。会解析成函数，当子组件渲染时，会调用此函数进行渲染。\n- 普通插槽渲染的作用域是父组件，作用域插槽的渲染作用域是当前子组件。\n")]),e._v(" "),t("h2",{attrs:{id:"vue-响应式原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-响应式原理"}},[e._v("#")]),e._v(" vue 响应式原理")]),e._v(" "),t("h3",{attrs:{id:"object-defineproperty"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#object-defineproperty"}},[e._v("#")]),e._v(" Object.defineProperty")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v(" "),t("p",[e._v("首先我们想到的是 Object.defineProperty,这是 es5 新增的一个 api,它可以允许我们为对象的属性来设定 getter 和 setter,从而我们可以劫持用户对对象属性的取值和赋值.比如以下代码:")]),e._v(" "),t("pre",[t("code",[e._v('const obj = {};\n\n\nlet val = "cjg";\n\nObject.defineProperty(obj, "name", {\n\nget() {\n\nconsole.log("劫持了你的取值操作啦");\n\nreturn val;\n\n},\n\nset(newVal) {\n\nconsole.log("劫持了你的赋值操作啦");\n\nval = newVal;\n\n},\n\n});\n\n\nconsole.log(obj.name);\n\nobj.name = "cwc";\n\nconsole.log(obj.name);\n\n')])]),e._v(" "),t("p",[e._v("我们通过 Object.defineProperty 劫持了 obj[name]的取值和赋值操作,因此我们就可以在这里做一些手脚啦,比如说,我们可以在 obj[name]被赋值的时候触发更新页面操作.")])]),e._v(" "),t("h3",{attrs:{id:"发布订阅模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发布订阅模式"}},[e._v("#")]),e._v(" 发布订阅模式")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v(" "),t("p",[e._v("发布订阅模式是设计模式中比较常见的一种,其中有两个角色：发布者和订阅者.多个订阅者可以向同一发布者订阅一个事件,当事件发生的时候,发布者通知所有订阅该事件的订阅者.我们来看一个例子了解下.")]),e._v(" "),t("pre",[t("code",[e._v('class Dep {\n\n  constructor() {\n\n    this.subs = [];\n\n  }\n\n  // 增加订阅者\n\n  addSub(sub) {\n\n    if (this.subs.indexOf(sub) < 0) {\n  \n      this.subs.push(sub);\n  \n    }\n\n  }\n\n  // 通知订阅者\n\n  notify() {\n\n    this.subs.forEach((sub) => {\n  \n      sub.update();\n  \n    });\n\n  }\n\n}\n\n\nconst dep = new Dep();\n\n\nconst sub = {\n\nupdate() {\n\nconsole.log("sub1 update");\n\n},\n\n};\n\n\nconst sub1 = {\n\nupdate() {\n\nconsole.log("sub2 update");\n\n},\n\n};\n\n\ndep.addSub(sub);\n\ndep.addSub(sub1);\n\ndep.notify(); //\n\n')])]),e._v(" "),t("ul",[t("li",[e._v("vue.js 首先通过 Object.defineProperty 来对要监听的数据进行 getter 和 setter 劫持,当数据的属性被赋值/取值的时候,vue.js 就可以察觉到并做相应的处理.")]),e._v(" "),t("li",[e._v("通过订阅发布模式,我们可以为对象的每个属性都创建一个发布者,当有其他订阅者依赖于这个属性的时候,则将订阅者加入到发布者的队列中.利用 Object.defineProperty 的数据劫持,在属性的 setter 调用的时候,该属性的发布者通知所有订阅者更新内容.")])])]),e._v(" "),t("h2",{attrs:{id:"nexttick"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nexttick"}},[e._v("#")]),e._v(" nextTick")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v(" "),t("p",[e._v("异步方法，异步渲染最后一步，与 "),t("code",[e._v("JS")]),e._v("事件循环联系紧密。主要使用了宏任务微任务（"),t("code",[e._v("setTimeout")]),e._v("、"),t("code",[e._v("promise")]),e._v("那些），定义了一个异步方法，多次调用 "),t("code",[e._v("nextTick")]),e._v("会将方法存入队列，通过异步方法清空当前队列。")])]),e._v(" "),t("h2",{attrs:{id:"vue-组件渲染顺序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-组件渲染顺序"}},[e._v("#")]),e._v(" Vue 组件渲染顺序")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v("\n渲染顺序：先父后子，完成顺序：先子后父\n"),t("p",[e._v("更新顺序：父更新导致子更新，子更新完成后父")]),e._v(" "),t("p",[e._v("销毁顺序：先父后子，完成顺序：先子后父")])]),e._v(" "),t("h2",{attrs:{id:"数据响应-数据劫持"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据响应-数据劫持"}},[e._v("#")]),e._v(" 数据响应(数据劫持)")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v(" "),t("p",[e._v("看完生命周期后,里面的 watcher 等内容其实是数据响应中的一部分.数据响应的实现由两部分构成: 观察者( watcher ) 和 依赖收集器( Dep ),其核心是 defineProperty 这个方法,它可以 重写属性的 get 与 set 方法,从而完成监听数据的改变.")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Observe (观察者)观察 props 与 state")]),e._v(" "),t("ul",[t("li",[e._v("遍历 props 与 state,对每个属性创建独立的监听器( watcher )")])])])]),e._v(" "),t("ul",[t("li",[t("p",[e._v("使用 defineProperty 重写每个属性的 get/set(defineReactive）")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("get: 收集依赖")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Dep.depend()")]),e._v(" "),t("ul",[t("li",[e._v("watcher.addDep()")])])])])]),e._v(" "),t("li",[t("p",[e._v("set: 派发更新")]),e._v(" "),t("ul",[t("li",[e._v("Dep.notify()")]),e._v(" "),t("li",[e._v("watcher.update()")]),e._v(" "),t("li",[e._v("queenWatcher()")]),e._v(" "),t("li",[e._v("nextTick")]),e._v(" "),t("li",[e._v("flushScheduleQueue")]),e._v(" "),t("li",[e._v("watcher.run()")]),e._v(" "),t("li",[e._v("updateComponent()")])])])])])]),e._v(" "),t("pre",[t("code",[e._v('let data = { a: 1 };\n\n// 数据响应性\n\nobserve(data);\n\n\n// 初始化观察者\n\nnew Watcher(data, "name", updateComponent);\n\ndata.a = 2;\n\n\n// 简单表示用于数据更新后的操作\n\nfunction updateComponent() {\n\n  vm._update(); // patchs\n\n}\n\n\n// 监视对象\n\nfunction observe(obj) {\n\n  // 遍历对象,使用 get/set 重新定义对象的每个属性值\n\n  Object.keys(obj).map((key) => {\n\n    defineReactive(obj, key, obj[key]);\n\n  });\n\n}\n\n\nfunction defineReactive(obj, k, v) {\n\n  // 递归子属性\n\n  if (type(v) == "object") observe(v);\n\n\n  // 新建依赖收集器\n\n  let dep = new Dep();\n\n  // 定义get/set\n\n  Object.defineProperty(obj, k, {\n\n    enumerable: true,\n  \n    configurable: true,\n  \n    get: function reactiveGetter() {\n  \n      // 当有获取该属性时,证明依赖于该对象,因此被添加进收集器中\n  \n      if (Dep.target) {\n  \n        dep.addSub(Dep.target);\n  \n      }\n  \n      return v;\n  \n    },\n  \n    // 重新设置值时,触发收集器的通知机制\n  \n    set: function reactiveSetter(nV) {\n  \n      v = nV;\n  \n      dep.nofify();\n  \n    },\n\n  });\n\n}\n\n\n// 依赖收集器\n\nclass Dep {\n\n  constructor() {\n\n    this.subs = [];\n\n  }\n\n  addSub(sub) {\n\n    this.subs.push(sub);\n\n  }\n\n  notify() {\n\n    this.subs.map((sub) => {\n  \n      sub.update();\n  \n    });\n\n  }\n\n}\n\n\nDep.target = null;\n\n\n// 观察者\n\nclass Watcher {\n\n  constructor(obj, key, cb) {\n\n    Dep.target = this;\n  \n    this.cb = cb;\n  \n    this.obj = obj;\n  \n    this.key = key;\n  \n    this.value = obj[key];\n  \n    Dep.target = null;\n\n  }\n\n  addDep(Dep) {\n\n    Dep.addSub(this);\n\n  }\n\n  update() {\n\n    this.value = this.obj[this.key];\n  \n    this.cb(this.value);\n\n  }\n\n  before() {\n\n    callHook("beforeUpdate");\n\n  }\n\n}\n\n  ')])])]),e._v(" "),t("h2",{attrs:{id:"vue-如何从真实-dom-到虚拟-dom"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-如何从真实-dom-到虚拟-dom"}},[e._v("#")]),e._v(" Vue 如何从真实 dom 到虚拟 dom")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v("\n涉及到Vue中的模板编译原理，主要过程：\n"),t("p",[e._v("将模板转换成 "),t("code",[e._v("ast")]),e._v(" 树， "),t("code",[e._v("ast")]),e._v(" 用对象来描述真实的 "),t("code",[e._v("JS")]),e._v("语法（将真实 "),t("code",[e._v("DOM")]),e._v("转换成虚拟 "),t("code",[e._v("DOM")]),e._v("）")]),e._v(" "),t("p",[e._v("优化树")]),e._v(" "),t("p",[e._v("将 "),t("code",[e._v("ast")]),e._v(" 树生成代码")])]),e._v(" "),t("h2",{attrs:{id:"用-vnode-来描述一个-dom-结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#用-vnode-来描述一个-dom-结构"}},[e._v("#")]),e._v(" 用 VNode 来描述一个 dom 结构")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v("\n涉及到Vue中的模板编译原理，主要过程：\n虚拟节点就是用一个对象来描述一个真实的DOM元素。首先将` template` （真实DOM）先转成` ast` ，` ast` 树通过` codegen` 生成` render` 函数，` render` 函数里的` _c` 方法将它转为虚拟dom\n")]),e._v(" "),t("h2",{attrs:{id:"virtual-dom-原理实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#virtual-dom-原理实现"}},[e._v("#")]),e._v(" virtual dom 原理实现")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("创建 dom 树")])]),e._v(" "),t("li",[t("p",[e._v("树的 diff,同层对比,输出 patchs(listDiff/diffChildren/diffProps)")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("没有新的节点,返回")])]),e._v(" "),t("li",[t("p",[e._v("新的节点 tagName 与 key 不变, 对比 props,继续递归遍历子树")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("对比属性(对比新旧属性列表):")]),e._v(" "),t("ul",[t("li",[e._v("旧属性是否存在与新属性列表中")]),e._v(" "),t("li",[e._v("都存在的是否有变化")]),e._v(" "),t("li",[e._v("是否出现旧列表中没有的新属性")])])]),e._v(" "),t("li",[t("p",[e._v("tagName 和 key 值变化了,则直接替换成新节点")])])])])])]),e._v(" "),t("li",[t("p",[e._v("渲染差异")]),e._v(" "),t("ul",[t("li",[e._v("遍历 patchs, 把需要更改的节点取出来")]),e._v(" "),t("li",[e._v("局部更新 dom")])])])]),e._v(" "),t("pre",[t("code",[e._v('// diff算法的实现\n\nfunction diff(oldTree, newTree) {\n\n  // 差异收集\n\n  let pathchs = {};\n\n  dfs(oldTree, newTree, 0, pathchs);\n\n  return pathchs;\n\n}\n\n\nfunction dfs(oldNode, newNode, index, pathchs) {\n\nlet curPathchs = [];\n\nif (newNode) {\n\n// 当新旧节点的 tagName 和 key 值完全一致时\n\nif (oldNode.tagName === newNode.tagName && oldNode.key === newNode.key) {\n\n// 继续比对属性差异\n\nlet props = diffProps(oldNode.props, newNode.props);\n\ncurPathchs.push({ type: "changeProps", props });\n\n// 递归进入下一层级的比较\n\ndiffChildrens(oldNode.children, newNode.children, index, pathchs);\n\n} else {\n\n// 当 tagName 或者 key 修改了后,表示已经是全新节点,无需再比\n\ncurPathchs.push({ type: "replaceNode", node: newNode });\n\n}\n\n}\n\n\n// 构建出整颗差异树\n\nif (curPathchs.length) {\n\nif (pathchs[index]) {\n\npathchs[index] = pathchs[index].concat(curPathchs);\n\n} else {\n\npathchs[index] = curPathchs;\n\n}\n\n}\n\n}\n\n\n// 属性对比实现\n\nfunction diffProps(oldProps, newProps) {\n\nlet propsPathchs = [];\n\n// 遍历新旧属性列表\n\n// 查找删除项\n\n// 查找修改项\n\n// 查找新增项 mutation\n\nforin(olaProps, (k, v) => {\n\nif (!newProps.hasOwnProperty(k)) {\n\npropsPathchs.push({ type: "remove", prop: k });\n\n} else {\n\nif (v !== newProps[k]) {\n\npropsPathchs.push({ type: "change", prop: k, value: newProps[k] });\n\n}\n\n}\n\n});\n\nforin(newProps, (k, v) => {\n\nif (!oldProps.hasOwnProperty(k)) {\n\npropsPathchs.push({ type: "add", prop: k, value: v });\n\n}\n\n});\n\nreturn propsPathchs;\n\n}\n\n\n// 对比子级差异\n\nfunction diffChildrens(oldChild, newChild, index, pathchs) {\n\n// 标记子级的删除/新增/移动\n\nlet { change, list } = diffList(oldChild, newChild, index, pathchs);\n\nif (change.length) {\n\nif (pathchs[index]) {\n\npathchs[index] = pathchs[index].concat(change);\n\n} else {\n\npathchs[index] = change;\n\n}\n\n}\n\n\n// 根据 key 获取原本匹配的节点,进一步递归从头开始对比\n\noldChild.map((item, i) => {\n\nlet keyIndex = list.indexOf(item.key);\n\nif (keyIndex) {\n\nlet node = newChild[keyIndex];\n\n// 进一步递归对比\n\ndfs(item, node, index, pathchs);\n\n}\n\n});\n\n}\n\n\n// 列表对比,主要也是根据 key 值查找匹配项\n\n// 对比出新旧列表的新增/删除/移动\n\nfunction diffList(oldList, newList, index, pathchs) {\n\nlet change = [];\n\nlet list = [];\n\nconst newKeys = getKey(newList);\n\noldList.map((v) => {\n\nif (newKeys.indexOf(v.key) > -1) {\n\nlist.push(v.key);\n\n} else {\n\nlist.push(null);\n\n}\n\n});\n\n\n// 标记删除\n\nfor (let i = list.length - 1; i >= 0; i--) {\n\nif (!list[i]) {\n\nlist.splice(i, 1);\n\nchange.push({ type: "remove", index: i });\n\n}\n\n}\n\n\n// 标记新增和移动\n\nnewList.map((item, i) => {\n\nconst key = item.key;\n\nconst index = list.indexOf(key);\n\nif (index === -1 || key == null) {\n\n// 新增\n\nchange.push({ type: "add", node: item, index: i });\n\nlist.splice(i, 0, key);\n\n} else {\n\n// 移动\n\nif (index !== i) {\n\nchange.push({\n\ntype: "move",\n\nform: index,\n\nto: i,\n\n});\n\nmove(list, index, i);\n\n}\n\n}\n\n});\n\n\nreturn { change, list };\n\n}\n\n')])])]),e._v(" "),t("h2",{attrs:{id:"proxy-相比于-defineproperty-的优势"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#proxy-相比于-defineproperty-的优势"}},[e._v("#")]),e._v(" Proxy 相比于 defineProperty 的优势")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v(" "),t("ul",[t("li",[e._v("数组变化也能监听到")]),e._v(" "),t("li",[e._v("不需要深度遍历监听")])])]),e._v(" "),t("h2",{attrs:{id:"vue-router-有哪几种导航守卫"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-有哪几种导航守卫"}},[e._v("#")]),e._v(" vue-router 有哪几种导航守卫?")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v(" "),t("ul",[t("li",[e._v("全局守卫")]),e._v(" "),t("li",[e._v("路由独享守卫")]),e._v(" "),t("li",[e._v("路由组件内的守卫")])])]),e._v(" "),t("h2",{attrs:{id:"vue-为什么用-function-实现类-而不是-es6-的-class"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-为什么用-function-实现类-而不是-es6-的-class"}},[e._v("#")]),e._v(" Vue 为什么用 function 实现类,而不是 ES6 的 class")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v(" "),t("p",[e._v("很多的 mixin 的函数调用,把 Vue 当参数传入,它的功能个都是给 VUe 的 prototype 上扩展一些方法,Vue 按功能把这些扩展分散到多个模块中去实现,而不是一个模块实现所有,这种方式 Class 是很难实现的,这么做的好处是非常方便代码的维护和管理")]),e._v(" "),t("p",[e._v("在 Vue3 中使用 Function-base API")]),e._v(" "),t("p",[e._v("对比 Class API")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("更灵活的逻辑复用能力")])]),e._v(" "),t("li",[t("p",[e._v("更好的 TypeScript 类型推到支持")])]),e._v(" "),t("li",[t("p",[e._v("更好的性能")])]),e._v(" "),t("li",[t("p",[e._v("Tree-shaking 友好")])]),e._v(" "),t("li",[t("p",[e._v("代码更容易被压缩")])])])]),e._v(" "),t("h2",{attrs:{id:"vue3-的优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue3-的优点"}},[e._v("#")]),e._v(" vue3 的优点")]),e._v(" "),t("details",[t("summary",[e._v("答案")]),e._v(" "),t("ul",[t("li",[e._v("更小")])]),e._v(" "),t("blockquote",[t("p",[e._v("移除了一些不常用的 API,引入了 tree-shaking")])]),e._v(" "),t("ul",[t("li",[e._v("更快")])]),e._v(" "),t("blockquote",[t("p",[e._v("diff 算法优化")])]),e._v(" "),t("blockquote",[t("p",[e._v("静态提升")])]),e._v(" "),t("blockquote",[t("p",[e._v("事件监听缓存")])]),e._v(" "),t("blockquote",[t("p",[e._v("SSR 优化")])]),e._v(" "),t("ul",[t("li",[e._v("TypeScript 支持")]),e._v(" "),t("li",[e._v("API 设计一致性")]),e._v(" "),t("li",[e._v("提升自身可维护性")]),e._v(" "),t("li",[e._v("开放更多的底层功能")])])])])}),[],!1,null,null,null);n.default=a.exports}}]);